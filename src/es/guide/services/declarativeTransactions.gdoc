
{hidden}

h3. Default Declarative Transactions

Services are typically involved with coordinating logic between [domain classes|guide:GORM], and hence often involved with persistence that spans large operations. Given the nature of services, they frequently require transactional behaviour. You can use programmatic transactions with the [withTransaction|domainClasses] method, however this is repetitive and doesn't fully leverage the power of Spring's underlying transaction abstraction.

Services enable transaction demarcation, which is a declarative way of defining which methods are to be made transactional. All services are transactional by default. To disable this set the @transactional@ property to @false@:

{code:java}
class CountryService {
    static transactional = false
}
{code}
{hidden}

H3. Transacciones declarativa predeterminadoServicios normalmente est√°n involucrados con la l√≥gica coordinaci√≥n entre [dominio classes|guide:GORM] y, por tanto, a menudo participan con persistencia que abarca grandes operaciones. Dada la naturaleza de los servicios, que con frecuencia requieren comportamiento transaccional. Puede utilizar transacciones mediante programaci√≥n con el m√©todo [withTransaction|domainClasses], sin embargo esto es repetitivo y no aprovecha el poder de primavera subyacente abstracci√≥n de transacci√≥n del.Los servicios permiten demarcaci√≥n de transacci√≥n, que es una forma declarativa de definir qu√© m√©todos se van a ser transaccional. Todos los servicios son transaccionales por defecto. Para desactivar este conjunto el @ transaccional @ propiedad @ false @:{C√≥digo: java}clase CountryService {}    Static transaccional = false}{C√≥digo}

{hidden}


You may also set this property to @true@ to make it clear that the service is intentionally transactional.

{warning}
Warning: [dependency injection|guide:dependencyInjectionServices] is the *only* way that declarative transactions work. You will not get a transactional service if you use the @new@ operator such as @new BookService()@
{warning}

The result is that all methods are wrapped in a transaction and automatic rollback occurs if a method throws a runtime exception (i.e. one that extends @RuntimeException@) or an @Error@. The propagation level of the transaction is by default set to [PROPAGATION_REQUIRED|http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/transaction/TransactionDefinition.html#PROPAGATION_REQUIRED].

{warning}
{hidden}

Tambi√©n puede establecer esta propiedad en true @ @ para que sea claro que el servicio es intencionalmente transaccional.Advertencia de {}Advertencia: [dependencia injection|guide:dependencyInjectionServices] es el * s√≥lo * forma en que funcionan las transacciones declarativas. No obtendr√° un servicio transaccional si usas el @ nuevo operador como @ nueva BookService() @ @Advertencia de {}El resultado es que todos los m√©todos est√°n envueltos en una transacci√≥n y reversi√≥n autom√°tica se produce si un m√©todo produce una excepci√≥n de tiempo de ejecuci√≥n (es decir, uno que se extiende de @ RuntimeException @) o un Error @ @. El nivel de propagaci√≥n de la transacci√≥n es por defecto [PROPAGATION_REQUIRED|http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/transaction/TransactionDefinition.html

{hidden}

Checked exceptions do *not* roll back transactions. Even though Groovy blurs the distinction between checked and unchecked exceptions, Spring isn't aware of this and its default behaviour is used, so it's important to understand the distinction between checked and unchecked exceptions.
{warning}

h3. Custom Transaction Configuration

Grails also fully supports Spring's @Transactional@ annotation for cases where you need more fine-grained control over transactions at a per-method level or need specify an alternative propagation level.

{note}
Annotating a service method with @Transactional@ disables the default Grails transactional behavior for that service (in the same way that adding @transactional=false@ does) so if you use any annotations you must annotate all methods that require transactions.
{note}
{hidden}

Comprueban hacen excepciones * no * deshacer transacciones. Aunque Groovy desdibuja la distinci√≥n entre activada y desactivadas excepciones, la primavera no es consciente de ello y su comportamiento predeterminado que se utiliza, por lo que es importante que entienda la diferencia entre excepciones checked y unchecked.Advertencia de {}H3. Configuraci√≥n personalizada de transacci√≥nGrails tambi√©n apoya plenamente @ transaccional la primavera @ anotaci√≥n para casos en que necesite m√°s un control preciso sobre las transacciones en un nivel por m√©todo o necesidad especifican un nivel de propagaci√≥n alternativo.{Nota}Anotar un m√©todo de servicio con @ transaccional @ deshabilita el comportamiento transaccional de Grails predeterminado para ese servicio (de la misma manera que a√±adir @ transaccional = false @ hace) por lo que si utiliza todas las anotaciones deber√°n anotar todos los m√©todos que requieren las transacciones.{Nota}

{hidden}


In this example @listBooks@ uses a read-only transaction, @updateBook@ uses a default read-write transaction, and @deleteBook@ is not transactional (probably not a good idea given its name).

{code}
import org.springframework.transaction.annotation.Transactional

class BookService {

    @Transactional(readOnly = true)
    def listBooks() {
        Book.list()
    }

    @Transactional
    def updateBook() {
        // …
    }

    def deleteBook() {
        // …
    }
}
{code}
{hidden}

En este ejemplo @ listBooks @ utiliza una transacci√≥n de s√≥lo lectura, @ updateBook @ utiliza un valor predeterminado read-write transacci√≥n y @ deleteBook @ no es transaccional (probablemente no es buena idea dada su nombre).{C√≥digo}org.springframework.transaction.annotation.Transactional de importaci√≥nclase BookService {}@ Transactional(readOnly = true)    Def listBooks() {}        Book.List()    }@ Transaccional    Def updateBook() {}        / / √â    }Def deleteBook() {}        / / √â    }}{C√≥digo}

{hidden}


You can also annotate the class to define the default transaction behavior for the whole service, and then override that default per-method. For example, this service is equivalent to one that has no annotations (since the default is implicitly @transactional=true@):

{code}
import org.springframework.transaction.annotation.Transactional

@Transactional
class BookService {

    def listBooks() {
        Book.list()
    }

    def updateBook() {
        // …
    }

    def deleteBook() {
        // …
    }
}
{code}
{hidden}

Puede anotar tambi√©n la clase para definir el comportamiento predeterminado de transacci√≥n para el servicio completo y luego reemplazar ese defecto por m√©todo. Por ejemplo, este servicio es equivalente a uno que no tiene anotaciones (puesto que el valor por defecto es impl√≠citamente @ transaccional = true @):{C√≥digo}org.springframework.transaction.annotation.Transactional de importaci√≥n@ Transaccionalclase BookService {}Def listBooks() {}        Book.List()    }Def updateBook() {}        / / √â    }Def deleteBook() {}        / / √â    }}{C√≥digo}

{hidden}


This version defaults to all methods being read-write transactional (due to the class-level annotation), but the @listBooks@ method overrides this to use a read-only transaction:

{code}
import org.springframework.transaction.annotation.Transactional

@Transactional
class BookService {

    @Transactional(readOnly = true)
    def listBooks() {
        Book.list()
    }

    def updateBook() {
        // …
    }

    def deleteBook() {
        // …
    }
}
{code}
{hidden}

Esta versi√≥n por defecto para todos los m√©todos de ser lectura transaccional (debido a la anotaci√≥n de nivel de clase), pero el @ listBooks @ anulaciones de m√©todo a utilizar una transacci√≥n s√≥lo lectura:{C√≥digo}org.springframework.transaction.annotation.Transactional de importaci√≥n@ Transaccionalclase BookService {}@ Transactional(readOnly = true)    Def listBooks() {}        Book.List()    }Def updateBook() {}        / / √â    }Def deleteBook() {}        / / √â    }}{C√≥digo}

{hidden}


Although @updateBook@ and @deleteBook@ aren't annotated in this example, they inherit the configuration from the class-level annotation.

For more information refer to the section of the Spring user guide on [Using \@Transactional|http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/transaction.html#transaction-declarative-annotations].

Unlike Spring you do not need any prior configuration to use @Transactional@; just specify the annotation as needed and Grails will detect them up automatically.
{hidden}

Aunque @ updateBook @ y @ deleteBook @ no est√°n anotados en este ejemplo, heredan la configuraci√≥n de la anotaci√≥n de nivel de clase.Para obtener m√°s informaci√≥n, consulte la secci√≥n del usuario primavera gu√≠a sobre [utilizando \@Transactional|http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/transaction.html
