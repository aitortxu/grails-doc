
{hidden}

h1. createCriteria

h2. Purpose

Creates and returns an instance of Grails' [HibernateCriteriaBuilder|api:grails.orm.HibernateCriteriaBuilder] that can be used to construct criteria queries.

h2. Examples

{code:java}
def c = Account.createCriteria()
def results = c.list {
    like("holderFirstName", "Fred%")
    and {
        between("balance", 500, 1000)
        eq("branch", "London")
    }
    maxResults(10)
    order("holderLastName", "desc")
}
{code}
{hidden}

H1. createCriteriaH2. FinCrea y devuelve una instancia de Grails' [HibernateCriteriaBuilder|api:grails.orm.HibernateCriteriaBuilder] que pueden utilizarse para construir consultas de criterios.H2. Ejemplos{C√≥digo: java}Def c = Account.createCriteria()resultados de Def = {} c.list    como ("holderFirstName", "Fred %")    y {}        entre ("equilibrio", 500, 1000)        EQ ("rama", "Londres")    }    maxResults(10)    orden ("holderLastName", "desc")}{C√≥digo}

{hidden}


To use pagination you would have to make another query to retrieve the total number of matching results. A better way is to pass the pagination values as arguments to the criteria method as shown below:

{code:java}
def c = Account.createCriteria()
def results = c.list (max: 10, offset: 10) {
    like("holderFirstName", "Fred%")
    and {
        between("balance", 500, 1000)
        eq("branch", "London")
    }
    order("holderLastName", "desc")
}
{code}
{hidden}

Para utilizar paginaci√≥n que tendr√≠a que hacer otra consulta para recuperar el n√∫mero total de resultados coincidentes. Es una mejor manera de pasar los valores de paginaci√≥n como argumentos al m√©todo de criterios, como se muestra a continuaci√≥n:{C√≥digo: java}Def c = Account.createCriteria()resultados de Def = c.list (m√°x.: 10, desv√≠o: 10) {}    como ("holderFirstName", "Fred %")    y {}        entre ("equilibrio", 500, 1000)        EQ ("rama", "Londres")    }    orden ("holderLastName", "desc")}{C√≥digo}

{hidden}


This will return a [PagedResultList|api:grails.orm.PagedResultList] which has a getTotalCount() method to return the total number of matching records for pagination. Two queries are still run, but they're run for you and the results and total count are combined in the @PagedResultList@.

{code:java}
println "Rendering ${results.size()} Accounts of ${results.totalCount}"
{code}

h2. Description

Criteria queries are a type-safe, advanced way to query that uses a Groovy builder to construct potentially complex queries. It is a much better alternative to using a StringBuilder to dynamically construct an HQL query. Refer to the user guide section on [Criteria|guide:criteria] for usage instructions.
{hidden}

Esto devolver√° un [PagedResultList|api:grails.orm.PagedResultList] que tiene un m√©todo getTotalCount() para devolver el n√∫mero total de registros coincidentes para la paginaci√≥n. Dos consultas est√°n funcionando, pero est√° corren para usted y recuento total de los resultados se combinan en el @ PagedResultList @.{C√≥digo: java}Console.println "Cuentas de ${results.size()} de procesamiento de ${results.totalCount}"{C√≥digo}H2. Descripci√≥nConsultas de criterios son un tipo de seguros, avanzada forma de consulta que utiliza un constructor Groovy para construir consultas potencialmente complejas. Es una mejor alternativa al uso de un StringBuilder para construir din√°micamente una consulta HQL. Consulte la secci√≥n Gu√≠a de usuario de [Criteria|guide:criteria] para obtener instrucciones de uso.

{hidden}


Method reference:

{table}
Method | Description
*list* | The default method; returns all matching rows.
*get* | Returns a unique result, i.e. just one row. The criteria has to be formed that way, that it only queries one row. This method is not to be confused with a limit to just the first row.
*scroll* | Returns a scrollable result set
*listDistinct* | If subqueries or associations are used, one may end up with the same row multiple times in the result set. In Hibernate one would do a "CriteriaSpecification.DISTINCT_ROOT_ENTITY". In Grails one can do it by just using this method.
{table}
{hidden}

Referencia de m√©todo:tabla de {}M√©todo | Descripci√≥n* lista * | El m√©todo predeterminado; Devuelve todas las filas coincidentes.* get * | Devuelve un √∫nico resultado, es decir, una sola fila. Los criterios tiene que formar de este modo, s√≥lo consultas de una fila. Este m√©todo no es debe ser confundido con un l√≠mite tan s√≥lo la primera fila.* desplazamiento * | Devuelve un conjunto de resultados desplazable* listDistinct * | Si se usan subconsultas o asociaciones, uno puede terminar con la misma fila varias veces en el conjunto de resultados. En hibernaci√≥n uno har√≠a un "CriteriaSpecification.DISTINCT_ROOT_ENTITY". En Grails, uno puede hacerlo s√≥lo con este m√©todo.tabla de {}

{hidden}


{warning}
The @listDistinct()@ method does not work well with the pagination options @maxResult@ and @firstResult@. If you need distinct results with pagination, we currently recommend that you use HQL. You can find out more information from [this blog post|http://floledermann.blogspot.com/2007/10/solving-hibernate-criterias-distinct.html].
{warning}

If you invoke the builder with no method name

{code:java}
c { … }
{code}
{hidden}

Advertencia de {}@ ListDistinct() @ m√©todo no funciona bien con las opciones de paginaci√≥n @ maxResult @ y @ firstResult @. Si necesita resultados concretos con paginaci√≥n, actualmente se recomienda que utilice HQL. Puede encontrar m√°s informaci√≥n de [este blog post|http://floledermann.blogspot.com/2007/10/solving-hibernate-criterias-distinct.html].Advertencia de {}Si se invoca el constructor sin nombre de m√©todo{C√≥digo: java}c {√â}{C√≥digo}

{hidden}


the @list()@ method will be invoked automatically. In other words, it's the equivalent of

{code:java}
c.list { … }
{code}

Below is a node reference for each criterion method:

{table}
{hidden}

@ list() @ m√©todo se invoca autom√°ticamente. En otras palabras, es el equivalente de{C√≥digo: java}c.List {√â}{C√≥digo}A continuaci√≥n es una referencia de nodo para cada m√©todo de criterio:tabla de {}

{hidden}

Node | Description | Example
*between* | Where the property value is between two distinct values | {code}
between("balance", 500, 1000)
{code}
 *eq* | Where a property equals a particular value.| {code}
eq("branch", "London")
{code}
 *eq* (case-insensitive) | A version of *eq* that supports an optional 3rd Map parameter to specify that the query be case-insensitive. | {code}
eq("branch", "london", [ignoreCase: true])
{code}
 *eqProperty* | Where one property must equal another | {code}
eqProperty("lastTx", "firstTx")
{code}
{hidden}

Nodo | Descripci√≥n | Ejemplo* entre * | Donde el valor de la propiedad es entre dos valores distintos | {C√≥digo}entre ("equilibrio", 500, 1000){C√≥digo} * eq * | Cuando una propiedad es igual a un valor determinado. | {C√≥digo}EQ ("rama", "Londres"){C√≥digo} * eq * (entre may√∫sculas y min√∫sculas) | Una versi√≥n de * eq * que soporta un opcional tercer par√°metro de mapa para especificar que la consulta entre may√∫sculas y min√∫sculas. | {C√≥digo}EQ ("rama", "london", [ignoreCase: true]){C√≥digo} * eqProperty * | Cuando una propiedad debe ser igual otro | {C√≥digo}eqProperty ("lastTx", "firstTx"){C√≥digo}

{hidden}

 *gt* | Where a property is greater than a particular value | {code}
gt("balance",1000)
{code}
 *gtProperty* | Where a one property must be greater than another | {code}
gtProperty("balance", "overdraft")
{code}
 *ge* | Where a property is greater than or equal to a particular value | {code}
ge("balance", 1000)
{code}
 *geProperty* | Where a one property must be greater than or equal to another | {code}
geProperty("balance", "overdraft")
{code}
{hidden}

* gt * | Cuando una propiedad sea superior a un valor determinado | {C√≥digo}gt("balance",1000){C√≥digo} * gtProperty * | Donde una una propiedad debe ser mayor que otro | {C√≥digo}gtProperty ("equilibrio", "descubierto"){C√≥digo} * ge * | Cuando una propiedad es mayor o igual a un valor determinado | {C√≥digo}GE ("equilibrio", 1000){C√≥digo} * geProperty * | Donde una una propiedad debe ser mayor o igual a otro | {C√≥digo}geProperty ("equilibrio", "descubierto"){C√≥digo}

{hidden}

 *idEq* | Where an objects id equals the specified value | {code}
idEq(1)
{code}
 *ilike* | A case-insensitive 'like' expression | {code}
ilike("holderFirstName", "Steph%")
{code}
 *in* | Where a property is contained within the specified list of values. Can also be chained with the @not@ method where a property is not contained within the specified list of values. Note: 'in' is a Groovy reserve word, so it must be escaped by quotes. | {code}
'in'("age",[18..65]) or not {'in'("age",[18..65])}
{code}
 *isEmpty* | Where a collection property is empty | {code}
isEmpty("transactions")
{code}
{hidden}

* idEq * | Cuando un identificador de objetos es igual al valor especificado | {C√≥digo}idEq(1){C√≥digo} * ilike * | May√∫sculas y min√∫sculas 'como' expresi√≥n | {C√≥digo}iLike ("holderFirstName", "Steph %"){C√≥digo} * en * | Cuando una propiedad est√° dentro de la lista especificada de valores. Tambi√©n puede ser encadenados no @ @ m√©todo donde una propiedad no est√° contenida dentro de la lista especificada de valores con. Nota: 'en' es una palabra Groovy reserva, por lo que debe ser escapado por comillas. | {C√≥digo}' in'("age",[18..65]) o no {'in'("age",[18..65])}{C√≥digo} * isEmpty * | Cuando una propiedad de colecci√≥n est√° vac√≠a | {C√≥digo}isEmpty("transactions"){C√≥digo}

{hidden}

 *isNotEmpty* | Where a collection property is not empty | {code}
isNotEmpty("transactions")
{code}
 *isNull* | Where a property is @null@ | {code}
isNull("holderGender")
{code}
 *isNotNull* | Where a property is not @null@ | {code}
isNotNull("holderGender")
{code}
 *lt* | Where a property is less than a particular value | {code}
lt("balance", 1000)
{code}
{hidden}

* isNotEmpty * | Que no est√© vac√≠a de una propiedad de colecci√≥n | {C√≥digo}isNotEmpty("transactions"){C√≥digo} * isNull * | Cuando una propiedad es null @ @ | {C√≥digo}isNull("holderGender"){C√≥digo} * isNotNull * | Cuando una propiedad no es null @ @ | {C√≥digo}isNotNull("holderGender"){C√≥digo} * lt * | Cuando una propiedad es inferior a un valor determinado | {C√≥digo}lt ("equilibrio", 1000){C√≥digo}

{hidden}

 *ltProperty* | Where a one property must be less than another | {code}
ltProperty("balance", "overdraft")
{code}
 *le* | Where a property is less than or equal to a particular value | {code}
le("balance", 1000)
{code}
 *leProperty* | Where a one property must be less than or equal to another | {code}
leProperty("balance", "overdraft")
{code}
 *like* | Equivalent to SQL like expression | {code}
like("holderFirstName", "Steph%")
{code}
{hidden}

* ltProperty * | Donde una una propiedad debe ser menor que otro | {C√≥digo}ltProperty ("equilibrio", "descubierto"){C√≥digo} * le * | Cuando una propiedad es igual o inferior a un valor determinado | {C√≥digo}le ("equilibrio", 1000){C√≥digo} * leProperty * | Donde una una propiedad debe ser menor o igual a otro | {C√≥digo}leProperty ("equilibrio", "descubierto"){C√≥digo} * como * | Equivalente a SQL como expresi√≥n | {C√≥digo}como ("holderFirstName", "Steph %"){C√≥digo}

{hidden}

 *ne* | Where a property does not equal a particular value | {code}
ne("branch", "London")
{code}
 *neProperty* | Where one property does not equal another | {code}
neProperty("lastTx", "firstTx")
{code}
 *order* | Order the results by a particular property | {code}
order("holderLastName", "desc")
{code}
 *rlike* | Similar to like, but uses a regex. Only supported on Oracle and MySQL. | {code}
rlike("holderFirstName", /Steph.+/)
{code}
{hidden}

* ne * | Cuando una propiedad no es igual a un valor determinado | {C√≥digo}ne ("rama", "Londres"){C√≥digo} * neProperty * | Cuando una propiedad no coincide con otro | {C√≥digo}neProperty ("lastTx", "firstTx"){C√≥digo} * orden * | Ordenar los resultados por una propiedad determinada | {C√≥digo}orden ("holderLastName", "desc"){C√≥digo} * rlike * | Similar a gustar, pero utiliza una expresi√≥n regular. S√≥lo compatible con Oracle y MySQL. | {C√≥digo}RLIKE ("holderFirstName", /Steph. /){C√≥digo}

{hidden}

 *sizeEq* | Where a collection property's size equals a particular value | {code}
sizeEq("transactions", 10)
{code}
 *sizeGt* | Where a collection property's size is greater than a particular value | {code}
sizeGt("transactions", 10)
{code}
 *sizeGe* | Where a collection property's size is greater than or equal to a particular value | {code}
sizeGe("transactions", 10)
{code}
 *sizeLt* | Where a collection property's size is less than a particular value | {code}
sizeLt("transactions", 10)
{code}
{hidden}

* sizeEq * | Donde el tama√±o de la propiedad de una colecci√≥n equivale a un valor determinado | {C√≥digo}sizeEq ("transacciones", 10){C√≥digo} * sizeGt * | Donde el tama√±o de la propiedad de una colecci√≥n es mayor que un valor particular | {C√≥digo}sizeGt ("transacciones", 10){C√≥digo} * sizeGe * | Donde el tama√±o de la propiedad de una colecci√≥n es mayor o igual a un valor determinado | {C√≥digo}sizeGe ("transacciones", 10){C√≥digo} * sizeLt * | Donde el tama√±o de la propiedad de una colecci√≥n es inferior a un valor determinado | {C√≥digo}sizeLt ("transacciones", 10){C√≥digo}

{hidden}

 *sizeLe* | Where a collection property's size is less than or equal to a particular value | {code}
sizeLe("transactions", 10)
{code}
 *sizeNe* | Where a collection property's size is not equal to a particular value | {code}
sizeNe("transactions", 10)
{code}
 *sqlRestriction* | Use arbitrary SQL to modify the resultset  | {code}
sqlRestriction "char_length(first_name) = 4"
{code}
{table}

With dynamic finders, you have access to options such as @max@, @sort@, etc. These are available to criteria queries as well, but they have different names:

{table}
Name | Description | Example
*order*(String, String) | Specifies both the sort column (the first argument) and the sort order (either 'asc' or 'desc'). | {code}
order "age", "desc"
{code}
{hidden}

* sizeLe * | Donde el tama√±o de la propiedad de una colecci√≥n es menor o igual a un valor determinado | {C√≥digo}sizeLe ("transacciones", 10){C√≥digo} * sizeNe * | Donde el tama√±o de la propiedad de una colecci√≥n no es igual a un valor determinado | {C√≥digo}sizeNe ("transacciones", 10){C√≥digo} * sqlRestriction * | Utilizar SQL arbitraria para modificar el resultset | {C√≥digo}sqlRestriction "char_length(first_name) = 4"{C√≥digo}tabla de {}Con buscadores din√°micos, tienes acceso a opciones como @ max @, @ tipo @, etc.. Est√°n disponibles para consultas de criterios, pero tienen diferentes nombres:tabla de {}Nombre | Descripci√≥n | Ejemplo* orden * (String, String) | Especifica la columna de ordenaci√≥n (el primer argumento) y el orden ("asc" o "desc"). | {C√≥digo}orden "edad", "desc"{C√≥digo}

{hidden}

*firstResult*(int) | Specifies the offset for the results. A value of 0 will return all records up to the maximum specified. | {code}
firstResult 20
{code}
*maxResults*(int) | Specifies the maximum number of records to return. | {code}
maxResults 10
{code}
*cache*(boolean) | Indicates if the query should be cached (if the query cache is enabled). | {code}
cache @true@
{code}
{table}

Criteria also support the notion of projections. A projection is used to change the nature of the results. For example the following query uses a projection to count the number of distinct @branch@ names that exist for each @Account@:

{code:java}
{hidden}

*firstResult*(int) | Especifica el desplazamiento por los resultados. Un valor de 0 devolver√° todos los registros hasta el m√°ximo especificado. | {C√≥digo}firstResult 20{C√≥digo}*maxResults*(int) | Especifica el n√∫mero m√°ximo de registros para volver. | {C√≥digo}maxResults 10{C√≥digo}*Cache*(Boolean) | Indica si la consulta debe ser en la cach√© (si est√° activada la cach√© de consultas). | {C√≥digo}cach√© @ verdadero @{C√≥digo}tabla de {}Criterios tambi√©n apoyan la noci√≥n de proyecciones. Una proyecci√≥n se utiliza para cambiar la naturaleza de los resultados. Por ejemplo, la siguiente consulta utiliza una proyecci√≥n para contar el n√∫mero de distintas sucursales @ @ nombres que existen para cada cuenta @ @:{C√≥digo: java}

{hidden}

def c = Account.createCriteria()
def branchCount = c.get {
    projections {
        countDistinct "branch"
    }
}
{code}

The following table summarizes the different projections and what they do:

{table}
Name | Description | Example
*property* | Returns the given property in the returned results | {code:java}
property("firstName"){code}
*distinct* | Returns results using a single or collection of distinct property names | {code:java}
distinct("fn") or distinct(['fn', 'ln']){code}
*avg* | Returns the average value of the given property | {code:java}
avg("age"){code}
*count* | Returns the count of the given property name | {code:java}
count("branch"){code}
*countDistinct* | Returns the count of the given property name for distinct rows | {code:java}
countDistinct("branch"){code}
*groupProperty* | Groups the results by the given property | {code:java}
groupProperty("lastName"){code}
*max* | Returns the maximum value of the given property | {code:java}
max("age"){code}
*min* | Returns the minimum value of the given property | {code:java}
min("age"){code}
*sum* | Returns the sum of the given property | {code:java}
sum("balance"){code}
*rowCount* | Returns count of the number of rows returned | {code:java}
rowCount(){code}

{table}
{hidden}

Def c = Account.createCriteria()Def branchCount = {} c.get    proyecciones {}        countDistinct "rama"    }}{C√≥digo}La siguiente tabla resume las diferentes proyecciones y lo que hacen:tabla de {}Nombre | Descripci√≥n | Ejemplo* propiedad * | Devuelve la propiedad dada en los resultados devueltos | {C√≥digo: java}Property("FirstName") {c√≥digo}* distintos * | Devuelve los resultados utilizando un √∫nico o una colecci√≥n de nombres de propiedades distintas | {C√≥digo: java}DISTINCT("FN") o distinto (['fn', 'ln']) {c√≥digo}* avg * | Devuelve el valor medio de la propiedad determinada | {C√≥digo: java}AVG("Age") {c√≥digo}* Conde * | Devuelve el recuento del nombre dado propiedad | {C√≥digo: java}Count("Branch") {c√≥digo}* countDistinct * | Devuelve el recuento del nombre propiedad determinada para distintas filas | {C√≥digo: java}countDistinct("branch") {c√≥digo}* groupProperty * | Agrupa los resultados por la propiedad dada | {C√≥digo: java}groupProperty("lastName") {c√≥digo}* max * | Devuelve el valor m√°ximo de la propiedad determinada | {C√≥digo: java}Max("Age") {c√≥digo}* min * | Devuelve el valor m√≠nimo de la propiedad determinada | {C√≥digo: java}min("Age") {c√≥digo}* suma * | Devuelve la suma de la propiedad determinada | {C√≥digo: java}Sum("balance") {c√≥digo}* rowCount * | Devuelve el n√∫mero de filas devueltas | {C√≥digo: java}rowCount() {c√≥digo}tabla de {}
